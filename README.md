1. strings builder
2. интерфейсы - абстракция-контракт на поведение, используются для своеобразного ООП (в основном, встраивание/композиция/полиморфизм [последний с небольшими оговорками, насколько помнится])
3. RWMutex дает возможность поставить лок только на запись, чтобы выиграть немного производительности на переключениях контекста (наверно)
4. в небуферизированном канале операции на запись/чтение блокирующие, в небуферизированном - неблокирующие, пока в буфере есть место
5. 0, пустая структура не занимает места в памяти [но как это работает?]
6. Перегрузки операторов/методов в Golang нет
7. k,v в map не имеют порядка, но если просто вывести map в Print - будет сортировка по ключу
8. new - для базовых типов, возвращает ptr, не value, make - для slice/map/channel (объявление + инициализация для избежания ошибок с этими типами, лучше использовать make, особенно в сравнении с var [def value этих типов - nil])
9. make, var (опасно), m := map[T]T, s := []T{...}, получается, 3 способа
10. Создастся копия указателя без присваивания, поэтому a и b будут ссылаться на разные адреса и иметь в итоге разные значения (в примере). Чтобы изменить указатель через функцию без присваивания, можно передать указатель на указатель
11. wg в функции следует передавать по указателю, чтобы счетчик изменялся корректно, без копий. В примере будет deadlock
12. shadowing (скобки {} в golang создают область видимости в которой можно объявить переменную с уже имеющимся именем, поэтому n вне скобок и в скобке - разные переменные, выведется 0 (первая n вне скобок, т.к. вывод тоже вне скобок)
13. А) слайс, объявленный в примере, имеет len = cap; B) слайсы (как и остальные типы) передаются в функции по значению, но копия (параметр) будет изначально ссылаться на тот же массив, поэтому v[0] = 100 изменит и копию, и оригинальный слайс, но при  v = append(v, b) будет переполнение, и v уже будет содержать другую ссылку. Присваивания результату не происходит, поэтому будет выведено {100, 2, 3, 4, 5}
14. Похожая ситуация, но в 14 примере append происходит в самом начале, и оригинальный слайс переполняется, поэтому изменяться будет параметр. Сначала выведется измененная копия {b, b, a}; вторым - оригинальный слайс {a, a}
    
